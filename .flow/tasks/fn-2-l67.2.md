# fn-2-l67.2 创建 .factory/skills/ 基础目录结构

## Description

创建 Factory 技能的基础目录结构，配置 flowctl 路径。

**Size:** S
**Files:**
- `.factory/skills/` (新建目录)
- `.factory/skills/.gitkeep` (保持目录)

## Approach

1. 创建 `.factory/skills/` 目录
2. 添加 `.gitkeep` 文件
3. 定义 repo root 解析策略（含降级处理）
4. 验证 flowctl 从任意 cwd 可调用
5. 创建示例 SKILL.md 验证 Factory 加载

## Path Resolution Strategy

所有技能使用动态 repo root，含降级处理:

```bash
REPO_ROOT="${REPO_ROOT:-$(git rev-parse --show-toplevel 2>/dev/null || true)}"
if [ -z "$REPO_ROOT" ]; then
  echo "Error: Set REPO_ROOT=/absolute/path/to/repo (git rev-parse failed; cwd may be outside repo)."
  exit 1
fi
"$REPO_ROOT/.flow/bin/flowctl" <command>
```

**规则**: 若 `git rev-parse` 失败（cwd 在 repo 外），技能应输出清晰错误并退出，而非静默失败。

**注意**: flowctl 已存在于 `.flow/bin/`，由 fn-1-gs3 和 fn-2-l67 共享。

## Key context

- Factory 技能目录: `.factory/skills/<skill-name>/SKILL.md`
- flowctl 共享 fn-1-gs3 的路径策略
- 动态 repo root 支持任意 cwd 调用

## Acceptance

- [ ] `.factory/skills/` 目录已创建
- [ ] 目录可被 Factory 识别（通过任务 1 的验证方法确认）
- [ ] repo root 解析策略已定义，包含降级处理:
  ```bash
  REPO_ROOT="${REPO_ROOT:-$(git rev-parse --show-toplevel 2>/dev/null || true)}"
  if [ -z "$REPO_ROOT" ]; then
    echo "Error: Set REPO_ROOT=..."
    exit 1
  fi
  ```
- [ ] flowctl 从任意 cwd 可调用:
  ```bash
  # 从 repo 内
  cd /path/to/repo/subdir
  REPO_ROOT="$(git rev-parse --show-toplevel)"
  "$REPO_ROOT/.flow/bin/flowctl" list
  # 成功标准: 退出码 0，输出包含 epic 列表
  ```
- [ ] repo 外调用的降级行为验证:
  ```bash
  # 完整降级片段测试
  cd /tmp
  unset REPO_ROOT
  REPO_ROOT="${REPO_ROOT:-$(git rev-parse --show-toplevel 2>/dev/null || true)}"
  if [ -z "$REPO_ROOT" ]; then
    echo "Error: Set REPO_ROOT=/absolute/path/to/repo"
    exit 1
  fi
  # 成功标准: 输出 "Error: Set REPO_ROOT=..." 并退出码 1
  ```

## Done summary

TBD

## Evidence

- Commits:
- Tests:
- PRs:
